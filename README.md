# 延时任务

## 需求描述

在日常开发中，常常面临这样的需求：执行A任务后，在10秒后执行B任务。

解决方案有三种：

1、使用juc中的延时队列

优点：jdk自带工具，使用方便

缺点：任务未持久化，服务重启后任务丢失

2、数据库+定时任务

优点：任务持久化，保证任务可执行。

缺点：任务执行时间不精确，如果定时任务的周期为5s，那么任务执行时间的误差为(0,5]

3、消息队列MQ

优点：任务持久化，执行时间保证精确

缺点：引入中间件，增加系统复杂度。

由于三种方式各有优劣，于是我诞生了一个想法：将MQ中的延时队列功能做成一个组件，让服务自己生产消息，自己消费，相当于2、3两种方案的结合体，既能保证任务的可靠性，也能保证任务执行的精确性，岂不美哉！

## 架构设计

设计分为两个部分

1、存储任务

2、执行任务

任务的数据结构：

```
任务id：主键
任务名：任务的名称，与执行任务的方法对应，用于执行任务时寻找执行任务的方法
任务描述：任务描述
任务信息：放置执行任务所需的参数信息
执行时间：任务的执行时间
执行状态：任务执行状态，创建，执行中，执行成功，执行失败
失败原因：存放任务执行失败的原因
```

存储任务流程：

业务使用：执行A任务后，调用存储任务方法存储B任务

组件逻辑：判断B任务的执行时间，若执行时间小于5s，任务状态设置为执行中，否则状态为开始，往数据库插入B任务数据，如果任务为执行中，立即将任务放入juc延时队列。

执行任务流程：

定时扫描MySQL，扫描5s后之前需执行的任务，将任务放入延时队列。

从延时队列中取出任务，使用任务名定位到执行任务方法，调用方法，根据方法返回情况设置任务执行状态

维护任务方法的方式：

通过自定义注解：DelayTask(name="B"), 程序启动时，将加了该注解的方法注册到一个Map中。



## 问题

任务执行器采用延时队列的方式做到任务执行时间精准控制，但这样带来一个问题，队列的数据结构是fifo，延时队列的数据结构是堆树，取任务只能一个一个取，延时队列中还涉及了线程pack与unpack的过程，并发量是个问题。

而实际情况中，可能在某一个秒大量的延时任务涌现，一个一个取是不合理的，正确的做法应该是把这一秒内的所有任务一次性全部取出来。

由此发现，延时队列的关注点在于顺序性。而实际情况更加关注时间性，即只要求到某一时刻就把相应的任务执行即可，而不要求这些任务的顺序先后，这些任务完全可以并行执行。

这时就有一种更好的数据结构：时间轮


如何解决分布式场景？
是否要增加锁机制？
开启机制？
开启之后才调用分布式逻辑？

增加超时情况
增加清理数据库逻辑

